package sbtretarget

import java.io.File
import java.nio.file.Files

import sbt._

object Retarget {

  def retarget = Command.command("retarget") { state =>
    val aggregates = aggregate(state, withCurrent = true)
    val ss = (Seq.empty[Def.Setting[_]] /: aggregates) { (s, ref) =>
      s ++ doRetarget(state, ref)
    }

    Project.extract(state).append(ss, state)
  }

  def retargetRevert = Command.command("retargetRevert") { state =>
    val aggregates = aggregate(state, withCurrent = true)
    val ss = (Seq.empty[Def.Setting[_]] /: aggregates) { (s, ref) =>
      s ++ doRevert(state, ref)
    }

    Project.extract(state).append(ss, state)
  }

  def aggregate(state: State, withCurrent: Boolean): Seq[ProjectRef] = {
    val x = Project.extract(state); import x._
    val aggs = currentProject.aggregate
    if (withCurrent) currentRef +: aggs else aggs
  }

  private def doRetarget(state: State, ref: ProjectRef): Seq[Def.Setting[_]] = {
    val x = Project.extract(state); import x._

    val name = get(Keys.name in ref)
    val target = get(Keys.target in ref)
    val retargetBase = get(RetargetKeys.retargetBaseDirectory in ref)
    val retargetOrigin = get(RetargetKeys.retargetOrigin in ref)
    val retargetPrefix = get(RetargetKeys.retargetPrefix in ref)
    val retargetCopy = get(RetargetKeys.retargetCopyFiles in ref)

    if (isRelativeTo(retargetBase, target)) {
      state.log.info(s"already retarget $name to $target")
      ensureSymlink(retargetOrigin, target)
      Seq()
    } else {
      val temp = Files.createTempDirectory(retargetBase.toPath, retargetPrefix).toFile
      if (retargetCopy) IO.copyDirectory(target, temp, overwrite = true, preserveLastModified = true)
      val link = ensureSymlink(target, temp)
      state.log.info(s"Set target of $name to $temp")
      saveSettings(state, ref, link, temp)
    }
  }

  private def doRevert(state: State, ref: ProjectRef): Seq[Def.Setting[_]] = {
    val x = Project.extract(state); import x._

    val name = get(Keys.name in ref)
    val target = get(Keys.target in ref)
    val retargetBase = get(RetargetKeys.retargetBaseDirectory in ref)
    val retargetLink = get(RetargetKeys.retargetOrigin in ref)
    val retargetConfigFile = get(RetargetKeys.retargetConfigFile in ref)
    val retargetCopy = get(RetargetKeys.retargetCopyFiles in ref)

    IO.delete(retargetConfigFile)

    if (isRelativeTo(retargetBase, target)) {
      IO.delete(retargetLink)
      if (retargetCopy) IO.copyDirectory(target, retargetLink, overwrite = true, preserveLastModified = true)
      IO.delete(target)
      state.log.info(s"Set target of $name to $retargetLink")
      Seq(Keys.target in ref := retargetLink)
    } else {
      state.log.info(s"Nothing to undo for $name")
      Seq()
    }
  }

  private def saveSettings(state: State, ref: ProjectRef, link: File, target: File): Seq[Def.Setting[_]] = {
    val x = Project.extract(state); import x._

    val baseDir = get(Keys.baseDirectory in ref)
    val retargetConfig = get(RetargetKeys.retargetConfigFile in ref)

    val linkfile =
      IO.relativize(baseDir, link)
        .fold(s"""file("${link.getAbsolutePath}")""")(file => s"""baseDirectory.value / "$file"""")

    val targetSetting = s"""target := file("${target.getAbsolutePath}")"""
    val linkSetting = s"""retargetOrigin := $linkfile"""
    val settings = Seq(header, targetSetting, linkSetting).map(_ + newline)
    IO.writeLines(retargetConfig, settings, append = false)

    Seq(Keys.target in ref := target, RetargetKeys.retargetOrigin in ref := link)
  }

  private def ensureSymlink(link: File, target: File): File =
    if (Files.isSymbolicLink(link.toPath)) link
    else {
      if (link.exists) IO.delete(link)
      Files.createSymbolicLink(link.toPath, target.toPath).toFile
    }

  private def isRelativeTo(base: File, file: File): Boolean =
    IO.relativizeFile(base, file).isDefined

  private val header = "// generated by sbt-retarget plugin"

  private val newline = System.lineSeparator()
}
